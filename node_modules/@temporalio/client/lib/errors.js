"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isServerErrorResponse = exports.WorkflowContinuedAsNewError = exports.WorkflowUpdateRPCTimeoutOrCancelledError = exports.WorkflowUpdateFailedError = exports.WorkflowFailedError = exports.ServiceError = void 0;
exports.isGrpcServiceError = isGrpcServiceError;
exports.isGrpcDeadlineError = isGrpcDeadlineError;
exports.isGrpcCancelledError = isGrpcCancelledError;
const grpc_js_1 = require("@grpc/grpc-js");
const type_helpers_1 = require("@temporalio/common/lib/type-helpers");
/**
 * Generic Error class for errors coming from the service
 */
let ServiceError = class ServiceError extends Error {
    cause;
    constructor(message, opts) {
        super(message);
        this.cause = opts?.cause;
    }
};
exports.ServiceError = ServiceError;
exports.ServiceError = ServiceError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ServiceError')
], ServiceError);
/**
 * Thrown by the client while waiting on Workflow execution result if execution
 * completes with failure.
 *
 * The failure type will be set in the `cause` attribute.
 *
 * For example if the workflow is cancelled, `cause` will be set to
 * {@link CancelledFailure}.
 */
let WorkflowFailedError = class WorkflowFailedError extends Error {
    cause;
    retryState;
    constructor(message, cause, retryState) {
        super(message);
        this.cause = cause;
        this.retryState = retryState;
    }
};
exports.WorkflowFailedError = WorkflowFailedError;
exports.WorkflowFailedError = WorkflowFailedError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowFailedError')
], WorkflowFailedError);
/**
 * Thrown by the client while waiting on Workflow Update result if Update
 * completes with failure.
 */
let WorkflowUpdateFailedError = class WorkflowUpdateFailedError extends Error {
    cause;
    constructor(message, cause) {
        super(message);
        this.cause = cause;
    }
};
exports.WorkflowUpdateFailedError = WorkflowUpdateFailedError;
exports.WorkflowUpdateFailedError = WorkflowUpdateFailedError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowUpdateFailedError')
], WorkflowUpdateFailedError);
/**
 * Thrown by the client if the Update call timed out or was cancelled.
 * This doesn't mean the update itself was timed out or cancelled.
 */
let WorkflowUpdateRPCTimeoutOrCancelledError = class WorkflowUpdateRPCTimeoutOrCancelledError extends Error {
    cause;
    constructor(message, opts) {
        super(message);
        this.cause = opts?.cause;
    }
};
exports.WorkflowUpdateRPCTimeoutOrCancelledError = WorkflowUpdateRPCTimeoutOrCancelledError;
exports.WorkflowUpdateRPCTimeoutOrCancelledError = WorkflowUpdateRPCTimeoutOrCancelledError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowUpdateRPCTimeoutOrCancelledError')
], WorkflowUpdateRPCTimeoutOrCancelledError);
/**
 * Thrown the by client while waiting on Workflow execution result if Workflow
 * continues as new.
 *
 * Only thrown if asked not to follow the chain of execution (see {@link WorkflowOptions.followRuns}).
 */
let WorkflowContinuedAsNewError = class WorkflowContinuedAsNewError extends Error {
    newExecutionRunId;
    constructor(message, newExecutionRunId) {
        super(message);
        this.newExecutionRunId = newExecutionRunId;
    }
};
exports.WorkflowContinuedAsNewError = WorkflowContinuedAsNewError;
exports.WorkflowContinuedAsNewError = WorkflowContinuedAsNewError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowExecutionContinuedAsNewError')
], WorkflowContinuedAsNewError);
/**
 * Returns true if the provided error is a {@link GrpcServiceError}.
 */
function isGrpcServiceError(err) {
    return ((0, type_helpers_1.isError)(err) &&
        typeof err?.details === 'string' &&
        (0, type_helpers_1.isRecord)(err.metadata));
}
/**
 * Returns true if the provided error or its cause is a {@link GrpcServiceError} with code DEADLINE_EXCEEDED.
 *
 * @see {@link Connection.withDeadline}
 */
function isGrpcDeadlineError(err) {
    while ((0, type_helpers_1.isError)(err)) {
        if (isGrpcServiceError(err) && err.code === grpc_js_1.status.DEADLINE_EXCEEDED) {
            return true;
        }
        err = err.cause;
    }
    return false;
}
/**
 * Returns true if the provided error or its cause is a {@link GrpcServiceError} with code CANCELLED.
 *
 * @see {@link Connection.withAbortSignal}
 */
function isGrpcCancelledError(err) {
    while ((0, type_helpers_1.isError)(err)) {
        if (isGrpcServiceError(err) && err.code === grpc_js_1.status.CANCELLED) {
            return true;
        }
        err = err.cause;
    }
    return false;
}
/**
 * @deprecated Use `isGrpcServiceError` instead
 */
exports.isServerErrorResponse = isGrpcServiceError;
//# sourceMappingURL=errors.js.map