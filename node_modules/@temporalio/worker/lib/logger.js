"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultLogger = exports.LogTimestamp = void 0;
exports.hasColorSupport = hasColorSupport;
exports.isFlushableLogger = isFlushableLogger;
const node_util_1 = require("node:util");
const supportsColor = __importStar(require("supports-color"));
const core_bridge_1 = require("@temporalio/core-bridge");
exports.LogTimestamp = Symbol.for('log_timestamp');
const severities = ['TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR'];
/**
 * @internal
 */
const loggerHasColorsSymbol = Symbol.for('logger_has_colors');
const stderrHasColors = !!supportsColor.stderr;
const format = node_util_1.formatWithOptions.bind(undefined, { colors: stderrHasColors });
/**
 * Log messages to `stderr` using basic formatting
 */
function defaultLogFunction(entry) {
    const { level, timestampNanos, message, meta } = entry;
    const date = new Date(Number(timestampNanos / 1000000n));
    if (meta === undefined) {
        process.stderr.write(`${format(date)} [${level}] ${message}\n`);
    }
    else {
        process.stderr.write(`${format(date)} [${level}] ${message} ${format(meta)}\n`);
    }
}
/**
 * Default worker logger - uses a default log function to log messages to `console.error`.
 * See constructor arguments for customization.
 */
class DefaultLogger {
    level;
    logFunction;
    severity;
    constructor(level = 'INFO', logFunction = defaultLogFunction) {
        this.level = level;
        this.logFunction = logFunction;
        this.severity = severities.indexOf(this.level);
        this[loggerHasColorsSymbol] =
            (logFunction === defaultLogFunction && stderrHasColors) ?? false;
    }
    log(level, message, meta) {
        if (severities.indexOf(level) >= this.severity) {
            const { [exports.LogTimestamp]: timestampNanos, ...rest } = meta ?? {};
            this.logFunction({
                level,
                message,
                meta: Object.keys(rest).length === 0 ? undefined : rest,
                timestampNanos: timestampNanos ?? core_bridge_1.native.getTimeOfDay(),
            });
        }
    }
    trace(message, meta) {
        this.log('TRACE', message, meta);
    }
    debug(message, meta) {
        this.log('DEBUG', message, meta);
    }
    info(message, meta) {
        this.log('INFO', message, meta);
    }
    warn(message, meta) {
        this.log('WARN', message, meta);
    }
    error(message, meta) {
        this.log('ERROR', message, meta);
    }
}
exports.DefaultLogger = DefaultLogger;
/**
 * @internal
 */
function hasColorSupport(logger) {
    return logger[loggerHasColorsSymbol] ?? false;
}
function isFlushableLogger(logger) {
    return 'flush' in logger && typeof logger.flush === 'function';
}
//# sourceMappingURL=logger.js.map