import vm from 'node:vm';
import { SourceMapConsumer } from 'source-map';
import { coresdk } from '@temporalio/proto';
import type { StackTraceFileLocation } from '@temporalio/workflow';
import { type SinkCall } from '@temporalio/workflow/lib/sinks';
import * as internals from '@temporalio/workflow/lib/worker-interface';
import { Activator } from '@temporalio/workflow/lib/internals';
import { Workflow } from './interface';
import { WorkflowBundleWithSourceMapAndFilename } from './workflow-worker-thread/input';
export declare function setUnhandledRejectionHandler(getWorkflowByRunId: (runId: string) => BaseVMWorkflow | undefined): void;
/**
 * Inject global objects as well as console.[log|...] into a vm context.
 */
export declare function injectGlobals(context: vm.Context): void;
/**
 * Global handlers for overriding stack trace preparation and promise hooks
 */
export declare class GlobalHandlers {
    currentStackTrace: StackTraceFileLocation[] | undefined;
    bundleFilenameToSourceMapConsumer: Map<string, SourceMapConsumer>;
    origPrepareStackTrace: ((err: Error, stackTraces: NodeJS.CallSite[]) => any) | undefined;
    private stopPromiseHook;
    installed: boolean;
    addWorkflowBundle(workflowBundle: WorkflowBundleWithSourceMapAndFilename): Promise<void>;
    removeWorkflowBundle(workflowBundle: WorkflowBundleWithSourceMapAndFilename): void;
    /**
     * Set the global hooks, this method is idempotent
     */
    install(): void;
    /**
     * Unset all installed global hooks
     *
     * This method is not called anywhere since we typically install the hooks in a separate thread which is cleaned up
     * after worker shutdown. Is debug mode we don't clean these up but that should be insignificant.
     */
    uninstall(): void;
    private overridePrepareStackTrace;
    private setPromiseHook;
}
export declare const globalHandlers: GlobalHandlers;
export type WorkflowModule = typeof internals;
/**
 * A Workflow implementation using Node.js' built-in `vm` module.
 */
export declare abstract class BaseVMWorkflow implements Workflow {
    readonly runId: string;
    protected context: vm.Context | undefined;
    protected activator: Activator;
    readonly workflowModule: WorkflowModule;
    unhandledRejection: unknown;
    constructor(runId: string, context: vm.Context | undefined, activator: Activator, workflowModule: WorkflowModule);
    /**
     * Send request to the Workflow runtime's worker-interface
     */
    getAndResetSinkCalls(): Promise<SinkCall[]>;
    /**
     * Send request to the Workflow runtime's worker-interface
     */
    activate(activation: coresdk.workflow_activation.IWorkflowActivation): Promise<coresdk.workflow_completion.IWorkflowActivationCompletion>;
    private activateQueries;
    /**
     * If called (by an external unhandledRejection handler), activations will fail with provided error.
     */
    setUnhandledRejection(err: unknown): void;
    /**
     * Call into the Workflow context to attempt to unblock any blocked conditions and microtasks.
     *
     * This is performed in a loop, going in and out of the VM, allowing microtasks to be processed
     * between each iteration of the outer loop, until there are no more conditions to unblock.
     */
    protected tryUnblockConditionsAndMicrotasks(): void;
    /**
     * Do not use this Workflow instance after this method has been called.
     */
    abstract dispose(): Promise<void>;
}
