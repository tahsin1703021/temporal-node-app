export type NonNullableObject<T> = {
    [P in keyof T]-?: NonNullable<T[P]>;
};
/** Shorthand alias */
export type AnyFunc = (...args: any[]) => any;
/** A tuple without its last element */
export type OmitLast<T> = T extends [...infer REST, any] ? REST : never;
/** F with all arguments but the last */
export type OmitLastParam<F extends AnyFunc> = (...args: OmitLast<Parameters<F>>) => ReturnType<F>;
export type OmitFirst<T> = T extends [any, ...infer REST] ? REST : never;
export type OmitFirstParam<T> = T extends (...args: any[]) => any ? (...args: OmitFirst<Parameters<T>>) => ReturnType<T> : never;
/** Require that T has at least one of the provided properties defined */
export type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;
}[Keys];
/** Verify that an type _Copy extends _Orig */
export declare function checkExtends<_Orig, _Copy extends _Orig>(): void;
export type Replace<Base, New> = Omit<Base, keyof New> & New;
export type UnionToIntersection<Union> = (Union extends unknown ? (distributedUnion: Union) => void : never) extends (mergedIntersection: infer Intersection) => void ? // The `& Union` is to allow indexing by the resulting type
Intersection & Union : never;
type IsEqual<A, B> = (<G>() => G extends A ? 1 : 2) extends <G>() => G extends B ? 1 : 2 ? true : false;
type Primitive = null | undefined | string | number | boolean | symbol | bigint;
type IsNull<T> = [T] extends [null] ? true : false;
type IsUnknown<T> = unknown extends T ? IsNull<T> extends false ? true : false : false;
type ObjectValue<T, K> = K extends keyof T ? T[K] : ToString<K> extends keyof T ? T[ToString<K>] : K extends `${infer NumberK extends number}` ? NumberK extends keyof T ? T[NumberK] : never : never;
type ToString<T> = T extends string | number ? `${T}` : never;
type KeysOfUnion<ObjectType> = ObjectType extends unknown ? keyof ObjectType : never;
type ArrayElement<T> = T extends readonly unknown[] ? T[0] : never;
type ExactObject<ParameterType, InputType> = {
    [Key in keyof ParameterType]: Exact<ParameterType[Key], ObjectValue<InputType, Key>>;
} & Record<Exclude<keyof InputType, KeysOfUnion<ParameterType>>, never>;
export type Exact<ParameterType, InputType> = IsEqual<ParameterType, InputType> extends true ? ParameterType : ParameterType extends Primitive ? ParameterType : IsUnknown<ParameterType> extends true ? unknown : ParameterType extends Function ? ParameterType : ParameterType extends unknown[] ? Array<Exact<ArrayElement<ParameterType>, ArrayElement<InputType>>> : ParameterType extends readonly unknown[] ? ReadonlyArray<Exact<ArrayElement<ParameterType>, ArrayElement<InputType>>> : ExactObject<ParameterType, InputType>;
export type RemovePrefix<Prefix extends string, Keys extends string> = {
    [k in Keys]: k extends `${Prefix}${infer Suffix}` ? Suffix : never;
}[Keys];
export declare function isRecord(value: unknown): value is Record<string, unknown>;
export declare function hasOwnProperty<X extends Record<string, unknown>, Y extends PropertyKey>(record: X, prop: Y): record is X & Record<Y, unknown>;
export declare function hasOwnProperties<X extends Record<string, unknown>, Y extends PropertyKey>(record: X, props: Y[]): record is X & Record<Y, unknown>;
export declare function isError(error: unknown): error is Error;
export declare function isAbortError(error: unknown): error is Error & {
    name: 'AbortError';
};
/**
 * Get `error.message` (or `undefined` if not present)
 */
export declare function errorMessage(error: unknown): string | undefined;
/**
 * Get `error.code` (or `undefined` if not present)
 */
export declare function errorCode(error: unknown): string | undefined;
/**
 * Asserts that some type is the never type
 */
export declare function assertNever(msg: string, x: never): never;
export type Class<E extends Error> = {
    new (...args: any[]): E;
    prototype: E;
};
/**
 * A decorator to be used on error classes. It adds the 'name' property AND provides a custom
 * 'instanceof' handler that works correctly across execution contexts.
 *
 * ### Details ###
 *
 * According to the EcmaScript's spec, the default behavior of JavaScript's `x instanceof Y` operator is to walk up the
 * prototype chain of object 'x', checking if any constructor in that hierarchy is _exactly the same object_ as the
 * constructor function 'Y'.
 *
 * Unfortunately, it happens in various situations that different constructor function objects get created for what
 * appears to be the very same class. This leads to surprising behavior where `instanceof` returns false though it is
 * known that the object is indeed an instance of that class. One particular case where this happens is when constructor
 * 'Y' belongs to a different realm than the constuctor with which 'x' was instantiated. Another case is when two copies
 * of the same library gets loaded in the same realm.
 *
 * In practice, this tends to cause issues when crossing the workflow-sandboxing boundary (since Node's vm module
 * really creates new execution realms), as well as when running tests using Jest (see https://github.com/jestjs/jest/issues/2549
 * for some details on that one).
 *
 * This function injects a custom 'instanceof' handler into the prototype of 'clazz', which is both cross-realm safe and
 * cross-copies-of-the-same-lib safe. It works by adding a special symbol property to the prototype of 'clazz', and then
 * checking for the presence of that symbol.
 */
export declare function SymbolBasedInstanceOfError<E extends Error>(markerName: string): (clazz: Class<E>) => void;
export {};
